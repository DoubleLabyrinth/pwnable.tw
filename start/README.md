# pwnable.tw -- Start

## 1. Challenge

  > Just a start.  
  > nc chall.pwnable.tw 10000  
  > [start](https://pwnable.tw/static/chall/start)

## 2. Solution

  Download ELF file `start` and drop it in IDA pro.

  Here is the assembly code:

  ```
  LOAD:08048000 ;
  LOAD:08048000 ; +-------------------------------------------------------------------------+
  LOAD:08048000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
  LOAD:08048000 ; |           Copyright (c) 2017 Hex-Rays, <support@hex-rays.com>           |
  LOAD:08048000 ; |                      License info: 48-3FBD-7F04-2C                      |
  LOAD:08048000 ; |                      Jiang Ying, Personal license                       |
  LOAD:08048000 ; +-------------------------------------------------------------------------+
  LOAD:08048000 ;
  LOAD:08048000 ; Input SHA256 : 0B64F96833009502EAF73AF1767DC6E125C8E4DE0A32336C2C3949ED40ED4A6F
  LOAD:08048000 ; Input MD5    : 4DE65E1A816D8EB93FA2C74EFFCDB38B
  LOAD:08048000 ; Input CRC32  : E543DBF7
  LOAD:08048000
  LOAD:08048000 ; File Name   : /Users/doublesine/Desktop/start
  LOAD:08048000 ; Format      : ELF for Intel 386 (Executable)
  LOAD:08048000 ; Imagebase   : 8048000
  LOAD:08048000 ;
  LOAD:08048000 ; Source File : 'start.s'
  LOAD:08048000
  LOAD:08048000                 .686p
  LOAD:08048000                 .mmx
  LOAD:08048000                 .model flat
  LOAD:08048000 .intel_syntax noprefix
  LOAD:08048000
  LOAD:08048000 ; ===========================================================================
  LOAD:08048000
  LOAD:08048000 ; Segment type: Pure code
  LOAD:08048000 ; Segment permissions: Read/Execute
  LOAD:08048000 LOAD            segment mempage public 'CODE' use32
  LOAD:08048000                 assume cs:LOAD
  LOAD:08048000                 ;org 8048000h
  LOAD:08048000                 assume es:nothing, ss:nothing, ds:LOAD, fs:nothing, gs:nothing
  LOAD:08048000 dword_8048000   dd 464C457Fh            ; DATA XREF: LOAD:0804803C↓o
  LOAD:08048000                                         ; File format: \x7FELF
  LOAD:08048004                 db 1                    ; File class: 32-bit
  LOAD:08048005                 db 1                    ; Data encoding: little-endian
  LOAD:08048006                 db 1                    ; File version
  LOAD:08048007                 db 0                    ; OS/ABI: UNIX System V ABI
  LOAD:08048008                 db 0                    ; ABI Version
  LOAD:08048009                 db 7 dup(0)             ; Padding
  LOAD:08048010                 dw 2                    ; File type: Executable
  LOAD:08048012                 dw 3                    ; Machine: Intel 386
  LOAD:08048014                 dd 1                    ; File version
  LOAD:08048018                 dd offset _start        ; Entry point
  LOAD:0804801C                 dd 34h                  ; PHT file offset
  LOAD:08048020                 dd 16Ch                 ; SHT file offset
  LOAD:08048024                 dd 0                    ; Processor-specific flags
  LOAD:08048028                 dw 34h                  ; ELF header size
  LOAD:0804802A                 dw 20h                  ; PHT entry size
  LOAD:0804802C                 dw 1                    ; Number of entries in PHT
  LOAD:0804802E                 dw 28h                  ; SHT entry size
  LOAD:08048030                 dw 5                    ; Number of entries in SHT
  LOAD:08048032                 dw 2                    ; SHT entry index for string table
  LOAD:08048034 ; ELF32 Program Header
  LOAD:08048034 ; PHT Entry 0
  LOAD:08048034                 dd 1                    ; Type: LOAD
  LOAD:08048038                 dd 0                    ; File offset
  LOAD:0804803C                 dd offset dword_8048000 ; Virtual address
  LOAD:08048040                 dd 8048000h             ; Physical address
  LOAD:08048044                 dd 0A3h                 ; Size in file image
  LOAD:08048048                 dd 0A3h                 ; Size in memory image
  LOAD:0804804C                 dd 5                    ; Flags
  LOAD:08048050                 dd 1000h                ; Alignment
  LOAD:08048054                 align 10h
  LOAD:08048054 LOAD            ends
  LOAD:08048054
  .text:08048060 ; ===========================================================================
  .text:08048060
  .text:08048060 ; Segment type: Pure code
  .text:08048060 ; Segment permissions: Read/Execute
  .text:08048060 _text           segment para public 'CODE' use32
  .text:08048060                 assume cs:_text
  .text:08048060                 ;org 8048060h
  .text:08048060                 assume es:nothing, ss:nothing, ds:LOAD, fs:nothing, gs:nothing
  .text:08048060
  .text:08048060 ; =============== S U B R O U T I N E =======================================
  .text:08048060
  .text:08048060
  .text:08048060                 public _start
  .text:08048060 _start          proc near               ; DATA XREF: LOAD:08048018↑o
  .text:08048060                 push    esp
  .text:08048061                 push    offset _exit
  .text:08048066                 xor     eax, eax
  .text:08048068                 xor     ebx, ebx
  .text:0804806A                 xor     ecx, ecx
  .text:0804806C                 xor     edx, edx
  .text:0804806E                 push    3A465443h
  .text:08048073                 push    20656874h
  .text:08048078                 push    20747261h
  .text:0804807D                 push    74732073h
  .text:08048082                 push    2774654Ch
  .text:08048087                 mov     ecx, esp        ; addr
  .text:08048089                 mov     dl, 14h         ; len
  .text:0804808B                 mov     bl, 1           ; fd
  .text:0804808D                 mov     al, 4
  .text:0804808F                 int     80h             ; LINUX - sys_write
  .text:08048091                 xor     ebx, ebx
  .text:08048093                 mov     dl, 3Ch
  .text:08048095                 mov     al, 3
  .text:08048097                 int     80h             ; LINUX - sys_read
  .text:08048099                 add     esp, 14h
  .text:0804809C                 retn
  .text:0804809C _start          endp ; sp-analysis failed
  .text:0804809C
  .text:0804809D
  .text:0804809D ; =============== S U B R O U T I N E =======================================
  .text:0804809D
  .text:0804809D ; Attributes: noreturn
  .text:0804809D
  .text:0804809D ; void exit(int status)
  .text:0804809D _exit           proc near               ; DATA XREF: _start+1↑o
  .text:0804809D                 pop     esp
  .text:0804809E                 xor     eax, eax
  .text:080480A0                 inc     eax
  .text:080480A1                 int     80h             ; LINUX - sys_exit
  .text:080480A1 _exit           endp ; sp-analysis failed
  .text:080480A1
  .text:080480A1 _text           ends
  .text:080480A1
  .text:080480A1
  .text:080480A1                 end _start
  ```

  We can see there are only two functions which are `_start` and `_exit`. Function `_start` has a BOF exploit at `.text:08048097` where you can send __0x3C__ chars at most. Obviously, it can affect the return address, so we can hijack `EIP` to stack and execute our own shellcode.

  However, we must know the address of stack. Otherwise, we cannot know where `EIP` redirects. Fortunately, at the beginning of `_start`, `.text:08048060`, program pushed `ESP` value. So we can redirect `EIP` to `.text:08048087` and let sys_write print `ESP` value out.

  After we gets `ESP` value, we can write shellcode to call __SYS_execve__ to execute `/bin/sh` to get a shell.

## 3. Usage

  Just run it.

  ```bash
  $ ./start.py
  ```
  
